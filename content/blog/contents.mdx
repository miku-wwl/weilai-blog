---
title: context
description: This is our first blog post
date: 2024-04-18
published: true
---

## 执行上下文

---

执行上下文是包含 JavaScript 操作原理的核心概念。如果能很好地理解这一点，就可以详细了解 JavaScript 的各种工作原理。

-如何基于 Scope 管理标识符和绑定到标识符的值 -寻呼发生的原因 -模块的工作原理 -与任务队列一起工作的事件处理程序 -异步处理的工作方式等

有助于理解等。慢慢了解吧

## **执行上下文中的组件**

---

执行上下文主要有三个主要组件。

1.**可变环境** -存储在本地范围内声明的变量、函数声明、参数等的环境 -保留初始创建时的环境快照 2.**Lexical Environment** -存储正在运行的代码的标识符（变量、函数、类等）的结构。 -与变量环境类似，但涉及更详细的信息，如声明为**\*`let\*\***、**\*`const\*\***的变量的寻址。 3.**this 绑定** -确定并保存执行上下文引用的**\*`this\*\***的值。 -根据函数调用方式（普通函数调用、方法调用、构造函数调用等），**\*'this`**的值会有所不同。

## **执行上下文的创建和生命周期**

---

执行上下文的生命周期分为以下阶段：

1.**创建步骤** -将新的上下文推送到执行上下文堆栈（EC Stack）。 -形成镜链，变量对象被激活。 -将设置外部环境信息和**‘this’**绑定。 2.**执行步骤** -变量和函数声明被分配给内存并初始化。 -执行代码，实时更新变量值或调用函数。 3.**结束步骤** -执行上下文的代码执行完成后，该上下文将在堆栈中弹出。 -从内存中删除所有本地变量和函数定义（除非有模块）。

## 源代码类型

---

ECMAScript 规范将源代码分为 4 种类型，这是因为根据 4 种类型，生成执行上下文的过程和管理内容不同。

| 源代码类型 | 说明 | 行为方式 |
| ---------- | ---- | -------- |

表示全局代码脚本的顶级代码。全局变量和函数属于此。创建全局上下文，并与全局对象（window 或 global）相关联。

-var 关键字变量和函数声明存储在全局对象中 -评估全局代码后，将创建全局运行上下文|
函数代码是指在函数内部编写的代码。生成函数上下文，每个函数调用都将新的上下文推送到堆栈中。 -示波器包含本地变量、参数、内部函数和 arguments 对象。
| eval 代码|表示 eval（）函数内部的代码块|-生成独立的上下文，评估 eval 内部的代码
-eval 代码的 scope 依赖于调用 eval 的上下文。
模块代码是指 ES6 模块的代码。
模块示波器限制在该模块内部--每个模块生成独立的上下文。 -模块内部声明的变量、函数、类等都包含在模块示波器中。

## 评估和执行源代码

---

所有源代码在运行之前都会经过评估过程，为运行代码做准备。JavaScript 引擎分为**“源代码的评估”**和**“源代码的执行”**过程进行处理。

在源代码评估过程中创建执行上下文，并首先运行**变量、函数的声明，将生成的变量或函数标识符注册到由执行上下文管理的 Scope（Lexical 环境中的环境记录）中。**

源代码评估完毕后，除宣言外的源代码将依次开始运行。这时，从执行上下文管理的 scope 中检索源代码要执行的信息，即变量或函数的引用。

更改值的变量或源代码的执行结果将在**重新运行上下文**管理的范围内注册。

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12657389-0f9c-46b5-bb62-6f11ae228c69/43abf473-ec8d-4421-817a-c74f66a97ec0/Untitled.png)

比如说

```jsx showLineNumbers
var x;
x = 1;
```

JavaScript 引擎分为源代码的“**评估”和“**执行**”两个过程进行处理，首先在**评估过程**中执行变量**声明“var x”。生成的变量标识符**“x”**在“执行接触”管理的“scope”中注册，并初始化为“undefined”。\*\*

在执行过程中，变量赋值语句**\*'x=1；`**只实行。此时，要为**\*`x\*\***变量分配值，首先必须确认**\*`x\*\***变量是否为声明的变量，为此，在**\*`执行上下文\*\***管理的**\*scop**中确认**\*`x\*\***变量是否被声明，如果已声明，则分配值，并在“执行上下文”中注册和管理分配结果。\*\*

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12657389-0f9c-46b5-bb62-6f11ae228c69/4d88a64d-7ca9-49bb-b0ec-5661a96fcf7b/Untitled.png)

## 执行上下文的角色

---

执行上下文的作用是什么？让我们看一个示例

```jsx showLineNumbers
//声明全局变量
const x = 1;
const y = 2;

function foo(a) {
  //声明本地变量
  const x = 10;
  const y = 20;
  //方法调用
  console.log(a + x + y);
}
//函数调用
foo(100);
//方法调用
console.log(x + y);
```

1.**全局代码评估**

**在“全局代码评估过程”**中，只有**宣言**先运行。因此，**将首先运行“变量声明”**和**“函数声明”**，结果生成的**“全局变量”**和**“全局函数”**将在**“执行上下文”**管理的**“全局范围”**中注册。**此时，声明为“var 关键字”的“全局变量”和定义为“函数声明”的全局函数将成为“全局对象”的属性和方法。**

2.**运行全局代码** 1.**“全局代码评估过程”结束后，运行时开始，全局代码开始依次运行。 2.为全局变量分配值并调用函数 3.函数调用时，顺序执行的全局代码暂停执行，进入函数内部。 3.**函数代码评估** 1.如果在全局代码执行过程中调用函数，**将开始“函数代码评估过程”**。 2.首先运行参数和地区变量声明，\*\***参数\***\*和\*\***地区变量\***\*将在\*\***执行上下文\***\*管理的\*\***地区范围**中注册。 3.在函数内部创建了可以像地区变量一样使用的\***“arguments”**对象，并在\***“地区标记”**中注册，\***“this 绑定”**也被确定。 4.**执行函数代码** 1.**为“参数”**和**“地区变量”**分配**值**，**调用 console.log**方法**。 2.**通过**“Scope Chain”**进行搜索，以调用“console.log”**方法。为此，**“函数代码的区域标记”**必须与**父标记的全局标记相关联**，**“console 标识符”**存在于全局对象的属性中。这意味着全局对象的属性必须像全局变量一样，可以通过全局 scope 进行搜索** 3.**通过**的**原型链**搜索“log”**属性。 4.**评估作为参数传递给 console.log**方法的表达式 a+x+y。（a，x，y 标识符通过**\*“Scope Chain”**进行搜索。
5.\***\*console.log\*\***方法执行结束后，函数代码执行过程结束，返回到函数调用之前，继续执行全局代码。

为了执行上述代码，必须区分**范围**来管理**“标识符”**和**“绑定值”**。**通过重叠关系形成“标记链”，可以搜索“标识符”**，**“全局对象”的属性也可以像搜索“全局变量”一样搜索**。也就是说，需要管理**“Scope”**、**“标识符”**、**“代码执行顺序”**等。

**“执行上下文”是一种内部机制，实现了对标识符（变量、函数、类等名称）的注册和管理以及代码执行顺序的管理，所有代码都通过“执行上下文”执行和管理。**

**“标识符”**和**“Scope”**由**“执行上下文”**的**Lexical 环境**管理，**“代码执行顺序”**由**执行上下文堆栈**管理。

## 执行上下文堆栈

---

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/12657389-0f9c-46b5-bb62-6f11ae228c69/062b9ca9-f843-4f0d-bae6-0dc368d4ec66/Untitled.png)

[来源：现代 JavaScript]

```jsx showLineNumbers
const x = 1;

function foo() {
  const y = 2;
  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}
foo(); // 6
```

上面的源代码由全局代码和函数代码组成。

执行上下文由堆栈数据结构管理。这称为**“执行上下文堆栈”**。

<aside>
📔 堆栈（stack）顾名思义是“堆积的堆”。堆放在餐厅的盘子堆、桌子上的书和堆放在一起的箱子都属于堆叠的例子。其中最具代表性的例子是“Pringles”。
堆栈的最大特点是后进先出（“LIFO”），最新的数据最先出现。

</aside>

1.**评估和执行全局代码**
1.JavaScript 引擎评估全局代码，生成**并将**“全局执行上下文”**推送到**“执行上下文”**。** 2.**“全局变量 x”**和**“全局函数 foo”**在**全局执行上下文中注册。** 3.当全局代码开始运行时，**为“全局变量 x”**分配值**，**调用“全局函数 foo**”**。 2.**评估和执行 foo 函数代码** 1.**如果调用“全局函数 foo**”**，则全局代码将暂停执行，**代码控制权将移到 foo 函数中**
2.JavaScript 引擎将**评估“foo 函数”内部的函数代码**，生成**并将**“foo 函数执行上下文”**推送到**“执行上下文堆栈”**。**
3.foo 函数的**“本地变量 y”**和**“嵌套函数 bar”**将在**foo 函数执行上下文中注册**。
4.“**foo 函数”代码开始运行**，为地区变量**“y”分配值**，并调用**嵌套函数 bar \*\*。 3.**评估和执行 bar 函数代码** 1.**如果“嵌套函数 bar”**被**调用**，**foo 函数代码的执行将暂停**，**代码的控制权将转移到 bar 函数内部**
2.JavaScript 引擎评估**bar 函数内部的函数代码**，生成**“bar 函数执行上下文”**，并将其推送到“执行上下文堆栈”**
3.bar 函数的本地变量 z 被注册到 bar 函数执行接触中。
4.bar 函数代码开始运行，为本地变量 z 赋值，调用 console.log 方法后 bar 函数终止。 4.**评估和执行 foo 函数代码**
1.bar 函数结束后，控制权将重新转移到 foo 函数。
2.JavaScript 引擎将 bar 函数执行上下文从执行上下文堆栈中弹出并删除。
3.foo 函数因没有可执行的代码而终止。 5.**返回全局代码** 1.**如果“foo 函数”终止**，控制权将转移到**全局代码**
2.JavaScript 引擎将**“foo 函数执行上下文”**从**执行上下文堆栈中弹出并删除。** 3.由于不存在要执行的代码，将从**堆栈中弹出并删除“**全局执行上下文**”。\*\*

### 结论

**“执行上下文堆栈”管理代码的执行顺序。运行上下文堆栈顶部的“运行上下文”始终是“当前运行代码的运行上下文”。**
